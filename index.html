<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />

    <!-- stop google thinking this page is in spanish -->
    <meta name="google" content="notranslate" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ESL Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/ace-builds@1.20.0/src-min-noconflict/ace.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ace-builds@1.20.0/src-min-noconflict/ace.min.js"></script>
    <style>
      /* layout taken from https://github.com/mwillsey/egg-smol */
      body {
        margin: 0;
        display: flex;
        height: 100vh;
        width: 100vw;
      }

      #editor {
        width: 60%;
        resize: horizontal;
        overflow: auto;
        padding: 5px;
      }

      /* someday */
      /* #editor .CodeMirror { */
      #editor #input {
        width: 97%;
        height: 97%;

        /* disable all textarea styling */
        border: none;
        overflow: auto;
        outline: none;
        -webkit-box-shadow: none;
        -moz-box-shadow: none;
        box-shadow: none;
        resize: none;
      }

      #panel {
        padding: 10px;
        flex: 1 1 0;
        border-left: 2px solid gray;

        display: flex;
        flex-flow: column;

        /* this size causes no resizing of the output div when the output lines get long. */
        /* an alternative is break-all, see below */
        /* max-width: 37%; */
      }

      #toolbar button {
        margin-right: 5px;
      }

      #output {
        font-family: monospace;
        margin-top: 10px;
        flex-grow: 1;
        white-space: pre-wrap;
        overflow-y: scroll;
      }

      .output-error {
        /* color: red; */
        background-color: red;
        color: white;
        border-radius: 3px;
        padding: 0px 5px;
      }

      .output-ok {
        /* color: green; */
        background-color: green;
        color: white;
        border-radius: 3px;
        padding: 0px 5px;
      }

      .output-line {
        overflow-wrap: anywhere;
        /* overflow-wrap: break-word; */
        /* background: white; */
        min-height: 1em;
        line-height: 1;
      }

      /* .output-line:hover {
        background: lightblue;
      } */
    </style>
  </head>

  <body>
    <div id="editor"></div>
    <!-- <div id="editor">
      <textarea id="input" spellcheck="false"></textarea>
    </div> -->
    <div id="panel">
      <div id="toolbar">
        <button id="run-btn" disabled onclick="run()">Run</button>
        <select
          name="examples"
          id="examples"
          onchange="load_selected_example()"
        >
          <option
            value="hello"
            data-text="effect Eff : unit

let test ()
(*@ ex i z ret;
  Eff(i->0, ret);
  req i-> z;
  Norm(i->z+1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in
  let ret = perform Eff in
  i := !i + 1;
  ret"
          >
            Hello world
          </option>
          <option value=src/examples/all.ml data-text="
let rec integers n =
  if n = 0 then []
  else n :: integers (n - 1)

let rec same x n =
  if n = 0 then []
  else x :: same x (n - 1)

let rec all p xs =
  match xs with
  | [] -> true
  | x :: xs1 -> p x && all p xs1

let rec any p xs =
  match xs with
  | [] -> false
  | x :: xs1 -> p x || any p xs1

let is_pos x = x > 0

let is_one x = if x = 1 then true else false

let all_one n
(*@ ex xs; all(is_one, xs, true); Norm(emp, xs) @*)
= same 1 n

(* this can't be proved yet *)
(* it's also very slow, so it's not running for now *)

(* let all_pos n
(*@ ex xs; all(is_pos, xs, true); Norm(emp, xs) @*)
= same 1 n *)

(* this can't be proved yet *)
(* let any_one n
(*@ req n>1/\emp; ex xs; any(is_one, xs, true); Norm(emp, xs) @*)
= same 1 n *)">src/examples/all.ml</option><option value=src/examples/applyN.ml data-text="let rec applyN_unfolded f x n
(*@ Norm(n=0/\emp, x) \/
  req n>0/\emp; ex r2; f(x, r2); ex r1; applyN_unfolded(f, r2, n-1, r1); Norm(emp, r1) @*)
= if n = 0 then x
  else let r = f x in applyN_unfolded f r (n-1)

let rec applyN f x n =
  if n = 0 then x
  else let r = f x in applyN f r (n-1)

let incr x = x + 1

let unsound_false ()
(*@ Norm(emp, 9) @*)
= applyN incr 0 10

let summary x n
(*@ Norm(emp, x+n) @*)
= applyN incr x n

let summary1_false x n
(*@ ex r4; Norm(r4=x+n-1/\emp, r4) @*)
= applyN incr x n

let summary2_false x n
(*@ ex r4; Norm(r4=x+n+1/\emp, r4) @*)
= applyN incr x n">src/examples/applyN.ml</option><option value=src/examples/closure.ml data-text="
let closures ()
(*@ ex i; Norm(i->[8;7;42], [8;7;42]) @*)
= let l = ref [] in
  l := 42 :: !l;
  let f i = l := i :: !l in
  let g h x = h x; l := (x+1) :: !l in
  g f 7;
  (* assert (!l = [8;7;42]); *)
  !l

let closures_with_local_state ()
(*@ ex i j; Norm(i->1 * j->2, 3) @*)
= let f =
    let x = ref 0 in
    fun () -> x := !x + 1; !x
  in
  let g =
    let x = ref 0 in
    fun () -> x := !x + 2; !x
  in
  f () + g ()

let simple_closures ()
(*@ Norm(emp, 4) @*)
= let counter =
    let x = ref 0 in
    fun () -> let r = !x in x := !x + 1; r
  in
  let x = ref 3 in
  counter ();
  counter () + !x">src/examples/closure.ml</option><option value=src/examples/compose.ml data-text="
let compose f g x = f (g x)

let f x = x := !x + 1; x

let g x = x := !x + !x; x

let caller1 () 
(*@ ex w; Norm(w->3, 3) @*)
= let x = ref 1 in
  let y1 = compose f g x in
  !y1

let caller2 ()
(*@ ex w; Norm(w->4, 4) @*)
= let y = ref 1 in 
  let y1 = compose g f y in
  !y1">src/examples/compose.ml</option><option value=src/examples/exception.ml data-text="
let failing x
(*@ ex i; req x->i; ex r; E(x->i+1 /\ i+1=3, r)
  \/
   ex i; req x->i; ens x->i+1 /\ res=i+1 /\ ~i+1=3 @*)
= x := !x + 1;
  if !x = 3 then perform E else !x

(* TODO there is a bug in handler reasoning, result should be 1 *)

let main ()
(*@ ex y; ens y->3 /\ res=3 @*)
= let y = ref 2 in
  match failing y with
  | effect E k -> 1
  | v -> v">src/examples/exception.ml</option><option value=src/examples/fold.ml data-text="
let rec length li = 
  match li with 
  | [] -> 0
  | x :: xs -> 1 + length xs

let rec foldr f li acc =
  match li with 
  | [] -> acc 
  | x :: xs -> 
    let acc' = f x acc in 
    foldr f xs acc'

let foldr_length xs init
(*@ ex r; length(xs, r); Norm(emp, r+init) @*)
= let g c t = 1 + t in
  foldr g xs init

let foldr_length_state x xs init
(*@ ex i; req x->i; ex r; length(xs, r); Norm(x->i+r, r+init) @*)
= let g c t = x := !x + 1; 1 + t in
  foldr g xs init

let rec sum li = 
  match li with 
  | [] -> 0
  | x :: xs -> x + sum xs

let foldr_sum xs init
(*@ ex r; sum(xs, r); Norm(emp, r+init) @*)
= let g c t = c + t in
  foldr g xs init

let foldr_sum_state x xs init
(*@ ex i; req x->i; ex r; sum(xs, r); Norm(x->i+r, r+init) @*)
= let g c t = x := !x + c; c + t in
  foldr g xs init">src/examples/fold.ml</option><option value=src/examples/iter.ml data-text="let rec integers x n =
  if n = 0 then []
  else x :: integers (x + 1) (n - 1)

let rec fill_list f n =
  if n = 0 then []
  else f () :: fill_list f (n - 1)

(* this cannot be proved because fill_list depends on i through counter,
   so the rewrite fails *)

let build_fill_false i n
(*@ ex r; integers(i, n, r) @*)
= let counter =
    let x = ref i in
    fun () ->
      let r = !x in
      x := !x + 1;
      r
  in
  fill_list counter n

(* what would work is to parameterize by the location *)

let build_fill x n
(*@ ex i; req x->i; ex r; integers(i, n, r) @*)
= let counter =
    fun () ->
      let r = !x in
      x := !x + 1;
      r
  in
  fill_list counter n">src/examples/iter.ml</option><option value=src/examples/map.ml data-text="
let rec map f xs =
  match xs with
  | [] -> []
  | x :: xs1 -> f x :: map f xs1

let id y = y

let map_id ys
(*@ Norm(emp, ys) @*)
= map id ys

let succ x = x + 1

let map_not_id_false ys
(*@ Norm(emp, ys) @*)
= map succ ys

(* ghost function that specifies what mapping succ should return *)
let rec succ_list xs =
  match xs with
  | [] -> []
  | x :: xs1 -> succ x :: succ_list xs1

(* we use succ_list in the statement of this lemma *)
let map_succ ys
(*@ ex r; succ_list(ys, r); Norm(emp, r) @*)
= map succ ys

let rec length xs =
  match xs with
  | [] -> 0
  | x :: xs1 -> 1 + length xs1

let cl_map xs x
(*@ ex i; req x->i; ex r; length(xs, r); ex r1; Norm(r1=xs/\x->i+r, r1) @*)
= let f a = x := !x+1; a in
  map f xs

(*

Proof sketch for inductive case:

map(f, xs, r) |-  req x -> init; length(xs, r); Norm(x-> init+r /\ ret =xs, ret) 

[unfold map]

Norm (xs=hd::tl, _); f(hd, r);                         map(f, tl, r1); Norm (emp, r::r1) |-  req x -> init; length(xs, r); Norm(x-> init+r /\ ret =xs, ret) 

[unfold f]

Norm (xs=hd::tl, _); req x->init; Norm(x->init+1, hd); map(f, tl, r1); Norm (emp, hd::r1) |-  req x -> init; length(xs, r); Norm(x-> init+r /\ ret =xs, ret) 

LHS: 

Norm (xs=hd::tl, _); req x->init; 
Norm(x->init+1, hd);  req x -> init'; <=> init+1=init'
length(tl, r'); Norm(x-> init'+r' /\ ret =tl, ret) 
Norm (emp, hd::tl)  

[norm]

Norm (xs=hd::tl, _); req x->init; 
length(tl, r'); Norm(x-> init+1+r' /\ ret =hd::tl, ret) |- 

RHS:
req x -> init; length(xs, r); Norm(x-> init+r /\ ret =xs, ret) 

[unfold length]

req x -> init; Norm (xs=hd::tl, _); 
length(tl, r'); Norm(x-> init+1+r' /\ ret =xs, ret) 

*)

(* this cannot be proved because the final stage doesn't match after one unfolding *)
let cl_map_1_false ()
(*@ Norm(emp, 0) @*)=
  let y = ref 0 in
  cl_map [] y;
  !y

(* this cannot be proved because we bound the number of unfoldings.
   we could fully unfold if given finite constants perhaps *)
let cl_map_12_false ()
(*@ Norm(emp, 2) @*)=
  let y = ref 0 in
  cl_map [1;2] y;
  !y

let rec incr_list init li =
  match li with 
  | [] -> []
  | x :: xs -> 
    init :: incr_list (init + 1) xs

(* let cl_map_incr_l xs x
(*@ ex i; req x->i; ex r; length(xs, r); ex r1; Norm(x->i+r, r1) @*)
= let f a = x := !x+1; !x in
  map f xs

let cl_map_incr_c xs x
(*@ ex i; req x->i; ex r; incr_list(i+1, xs, r); Norm(emp, r) @*)
= let f a = x := !x+1; !x in
  map f xs *)">src/examples/map.ml</option><option value=src/evaluation/0_heap_zero_once_twice.ml data-text="effect Zero : int 
effect Once : int 
effect Twice : int 

let test () 
(*@ ex i ret;
   Zero(i->0, ret);
   req i-> 0; 
   Norm(i->1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  let ret = perform Zero in 
  i := !i + 1;
  assert (!i = 1);
  ret

let main_aux ()
(*@ ex i;
   Norm(i->0, 100)
@*)
=
  match test () with
  | v -> v
  | effect Zero k -> 100
  | effect Once k ->
    (continue k 1); 
  | effect Twice k ->
    let _ = (continue (Obj.clone_continuation k) 1) in (continue k 2)">src/evaluation/0_heap_zero_once_twice.ml</option><option value=src/evaluation/10_memory_cell_nested.ml data-text="effect Read : int 
effect Write : int -> unit 

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let test ()
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, (x1+1), x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= 
  let x = read () in 
  let y = x + 1 in 
  write y;
  read () 

let write_handler i  
(*@ 
  ex x1; Read(emp, x1); 
  ex z; req i->z; 
  ex ret; Read(i->x1+1, ret); Norm(emp, ret)
@*)
= 
  match test () with
  | v -> v
  | effect (Write x) k -> i := x; (continue k ())


let read_handler  ()
(*@ 
  ex i; 
  Norm(i->1, 1)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match write_handler i with
  | v -> v 
  | effect Read k -> 
    let x = !i in
    (continue k (x))">src/evaluation/10_memory_cell_nested.ml</option><option value=src/evaluation/11_exchange.ml data-text="effect Exchange: int -> int

let exchange (m:int)
(*@  
   ex ret;
   Exchange(emp, m, ret);
   Norm(emp, ret)
@*)
= perform (Exchange m)


let exc_hanlder (y: int ref) (new_v:int): int
(*@  
   ex old_v; 
   req y -> old_v; 
   Norm(y -> new_v /\ res=old_v)
@*)
= match exchange new_v with 
  | v -> v 
  | effect (Exchange n) k -> 
    let old_v = !y in 
    y := n; 
    continue k old_v


let main ()
(*@  
  ex x;
  Norm(x -> 5, 11)
@*)
= 
  let x = ref 11 in 
  let r = exc_hanlder x 5 in 
  (* print_endline (string_of_int r); *)
  r">src/evaluation/11_exchange.ml</option><option value=src/evaluation/12_two_pointers.ml data-text="effect E: unit 

let two_locations () 
(*@ ex i j z1 z2 ret;
   E(i->0 * j->0, ret);
   req i->z1 * j->z2; 
   Norm(i->z1+1*j->z2+1, ret)
@*)
= let i = ref 0 in 
  let j = ref 0 in 
  let ret = perform (E) in 
  i := !i + 1;
  j := !j + 1;
  ret">src/evaluation/12_two_pointers.ml</option><option value=src/evaluation/1_heap_zero_once_twice.ml data-text="effect Zero : int 
effect Once : int 
effect Twice : int 

let test () 
(*@ ex i ret;
   Once(i->0, ret);
   req i-> 0; 
   Norm(i->1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  let ret = perform Once in 
  i := !i + 1;
  assert (!i = 1);
  ret

let main_aux ()
(*@ ex i;
   Norm(i->1, 1)
@*)
=
  match test () with
  | v -> v
  | effect Zero k -> (-1)
  | effect Once k ->
    (continue k 1); 
  | effect Twice k ->
    let _ = (continue (Obj.clone_continuation k) 1) in (continue k 2)">src/evaluation/1_heap_zero_once_twice.ml</option><option value=src/evaluation/2_heap_zero_once_twice.ml data-text="effect Zero : int 
effect Once : int 
effect Twice : int 

let test () 
(*@ ex i ret;
   Twice(i->0, ret);
   req i-> 0; 
   Norm(i->1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  let ret = perform Twice in 
  i := !i + 1;
  assert (!i = 1);
  ret

let main_false ()
(*@ ex i;
   Norm(i->2, 2)
@*)
=
  match test () with
  | v -> v
  | effect Zero k -> 100
  | effect Once k ->
    (continue k 1); 
  | effect Twice k ->
    let _ = (continue (Obj.clone_continuation k) 1) in (continue k 2)">src/evaluation/2_heap_zero_once_twice.ml</option><option value=src/evaluation/3_nestedHandlers.ml data-text="effect E : int 
effect F : string 

let foo () 
(*@ 
   ex ret; 
   F(emp, ret);
   Norm(emp, ret)
@*)
= perform F

let bar () 
(*@ 
   ex ret; 
   F(emp, ret);
   Norm(emp, ret)
@*)
=
  match foo () with 
  | x -> x 
  | effect E k -> assert false

let baz () 
(*@ 
   Norm(emp, 1)
@*)
=
  match bar () with 
  | x -> x 
  | effect F k -> continue k 1">src/evaluation/3_nestedHandlers.ml</option><option value=src/evaluation/4_memory_cell.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)


let read_handler () 
(*@ 
  ex i; 
  Norm(i->0,  0)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match read () with 
  | v -> v
  | effect Read k -> continue k (!i) 



let write_handler  ()
(*@ 
  ex i; 
  Norm(i->10,  10)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match write 10 with
  | v -> !i (*print_string (string_of_int !i) *)
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/4_memory_cell.ml</option><option value=src/evaluation/5_memory_cell.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n, ret);
   Norm(emp, ret)
@*)
= perform (Write n)


let read_handler ()
(*@ 
  ex i; 
  Norm(i->0, 0)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match read ();read () with 
  | v -> v
  | effect Read k -> (continue k (!i)) 



let write_handler  ()
(*@ 
  ex i; 
  Norm(i->20, 20)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match write 10; write 20 with
  | v -> !i (*print_string (string_of_int !i) *)
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/5_memory_cell.ml</option><option value=src/evaluation/6_memory_cell_mix_handler.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let test1 ()
(*@ 
  ex x2;
  Write(emp, 10, x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= 
  write 10;
  read ()

let test ()
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, (x1+1), x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= 
  let x = read () in 
  let y = x +1 in 
  write y;
  read () 

let handler () 
(*@ 
  ex i; 
  Norm(i->1,  1)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match test () with 
  | v -> !i
  | effect Read k -> (continue k (!i)) 
  | effect (Write x) k -> i := x; (continue k ())



let handler1 () 
(*@ 
  ex i; 
  Norm(i->10,  10)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match test1 () with 
  | v -> !i
  | effect Read k -> (continue k (!i)) 
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/6_memory_cell_mix_handler.ml</option><option value=src/evaluation/7_memory_cell_mix_handler.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)


let test ()
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, (x1+1), x2); 
  ex x3; 
  Read(emp, x3); 
  ex x4; 
  Write(emp, (x3+1), x4); 
  ex x5; 
  Read(emp, x5); 
  Norm(emp, x5)
@*)
= 
  let x = read () in 
  write (x+1);
  let z = read () in 
  write (z+1);
  read ()

let handler () 
(*@ 
  ex i; 
  Norm(i->2,  2)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match test () with 
  | v -> !i
  | effect Read k -> (continue k (!i)) 
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/7_memory_cell_mix_handler.ml</option><option value=src/evaluation/8_memory_cell_nested.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let client () 
(*@ 
  ex x2;
  Write(emp, 10, x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= write 10;
  read () 
  

let handler1 i 
(*@ 
  ex z x3;
  req i -> z;
  Read(i ->10, x3); 
  Norm(emp, x3)
@*)
= 
  match client () with
  | v -> v
  | effect (Write x) k -> i := x; (continue k ())


let handler2  ()
(*@ 
   ex i; 
   Norm(i->10, ())
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match handler1 i with
  | v -> () (*print_string (string_of_int !i) *)
  | effect Read k -> (continue k (!i))">src/evaluation/8_memory_cell_nested.ml</option><option value=src/evaluation/9_memory_cell_nested.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let client () 
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, 10, x2); 
  Norm(emp, x2)
@*)
= read ();
  write 10

let handler1 i  
(*@ 
  ex ret ret1 z; 
  Read(emp, ret); 
  req i-> z; 
  Norm(i->10,  ())
@*)
= 
  match client () with
  | v -> ()
  | effect (Write x) k -> i := x; (continue k ())


let handler2  ()
(*@ 
  ex i; 
  Norm(i->10,  ())
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match handler1 i with
  | v -> v (*print_string (string_of_int !i) *)
  | effect Read k -> (continue k (!i))">src/evaluation/9_memory_cell_nested.ml</option><option value=src/evaluation/abort.ml data-text="effect Zero : unit

let client () 
(*@ ex r; Zero(emp, (), r); req false/\emp; ex r1; Norm(false/\emp, r1) @*)
=
  perform (Zero ());
  assert false

let handler ()
(*@ ex r; Norm(r=3/\emp, r) @*)
=
  match client () with
  | v -> 2
  | effect Zero k -> 3

let invalid_false ()
(*@ ex r; Norm(false/\emp, r) @*)
=
  match client () with
  | v -> 2
  | effect Zero k -> continue k ()">src/evaluation/abort.ml</option>
        </select>
        <button id="share-btn" disabled onclick="share()">Share</button>
        <span style="display: inline-block">
          <!-- prevent the checkbox and label from wrapping separately -->
          <input type="checkbox" id="debug" style="vertical-align: middle" />
          <label for="debug" style="vertical-align: middle">Debug</label>
        </span>
      </div>
      <div id="output"></div>
    </div>
    <script type="text/javascript">
      const redirect_output = true;
      if (redirect_output) {
        const field = document.querySelector("#output");
        window.console = new Proxy(console, {
          get(_target, prop, _receiver) {
            let args = [...arguments];
            // old_console.warn(args);
            if (prop === "log") {
              return (...args) => {
                // field.value += args.join(' ') + '\n';
                field.innerHTML +=
                  '<div class="output-line">' +
                  args
                    .join(" ")
                    .replace(/\n/g, '</div><div class="output-line">') +
                  "</div>";
                // field.textContent += args.join(" ");
                // old_console.log(...args);
              };
            } else {
              return Reflect.get(...arguments);
            }
          },
        });
      }
    </script>
    <script src="coi-serviceworker.min.js"></script>
    <!-- z3-built has to be deferred -->
    <script type="text/javascript" src="z3-built.js"></script>
    <script type="text/javascript" src="ace_ocaml.js"></script>
    <script>
      // this is substituted at build time and is used in page.js
      function postExampleLoad() {
        console.log("Built Tue Oct 31 11:56:32 UTC 2023");
        console.log("loading z3...");
      }
    </script>
    <script type="text/javascript" src="page.js"></script>
    <!-- hipjs logs to the console (page) -->
    <script type="text/javascript" src="hipjs.bc.js"></script>
    <!-- bundle.js/main.js requires ocaml_ready (hipjs) and enable_buttons (page) to be defined -->
    <script type="text/javascript" src="bundle.js"></script>
  </body>
</html>
