<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />

    <!-- stop google thinking this page is in spanish -->
    <meta name="google" content="notranslate" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ESL Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/ace-builds@1.20.0/src-min-noconflict/ace.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ace-builds@1.20.0/src-min-noconflict/ace.min.js"></script>
    <style>
      /* layout taken from https://github.com/mwillsey/egg-smol */
      body {
        margin: 0;
        display: flex;
        height: 100vh;
        width: 100vw;
      }

      #editor {
        width: 60%;
        resize: horizontal;
        overflow: auto;
        padding: 5px;
      }

      /* someday */
      /* #editor .CodeMirror { */
      #editor #input {
        width: 97%;
        height: 97%;

        /* disable all textarea styling */
        border: none;
        overflow: auto;
        outline: none;
        -webkit-box-shadow: none;
        -moz-box-shadow: none;
        box-shadow: none;
        resize: none;
      }

      #panel {
        padding: 10px;
        flex: 1 1 0;
        border-left: 2px solid gray;

        display: flex;
        flex-flow: column;

        /* this size causes no resizing of the output div when the output lines get long. */
        /* an alternative is break-all, see below */
        /* max-width: 37%; */
      }

      #toolbar button {
        margin-right: 5px;
      }

      #output {
        font-family: monospace;
        margin-top: 10px;
        flex-grow: 1;
        white-space: pre-wrap;
        overflow-y: scroll;
      }

      .output-error {
        /* color: red; */
        background-color: red;
        color: white;
        border-radius: 3px;
        padding: 0px 5px;
      }

      .output-ok {
        /* color: green; */
        background-color: green;
        color: white;
        border-radius: 3px;
        padding: 0px 5px;
      }

      .output-line {
        overflow-wrap: anywhere;
        /* overflow-wrap: break-word; */
        /* background: white; */
        min-height: 1em;
        line-height: 1;
      }

      /* .output-line:hover {
        background: lightblue;
      } */
    </style>
  </head>

  <body>
    <div id="editor"></div>
    <!-- <div id="editor">
      <textarea id="input" spellcheck="false"></textarea>
    </div> -->
    <div id="panel">
      <div id="toolbar">
        <button id="run-btn" disabled onclick="run()">Run</button>
        <select
          name="examples"
          id="examples"
          onchange="load_selected_example()"
        >
          <option
            value="hello"
            data-text="effect Eff : unit

let test ()
(*@ ex i z ret;
  Eff(i->0, ret);
  req i-> z;
  Norm(i->z+1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in
  let ret = perform Eff in
  i := !i + 1;
  ret"
          >
            Hello world
          </option>
          <option value=src/examples/applyN.ml data-text="
let rec applyN_unfolded f x n
(*@
  Norm(n=0/\emp, x) \/
  req n>0/\emp; ex r2; f(x, r2); ex r1; applyN(f, r2, n-1, r1); Norm(emp, r1)
@*)
=
if n = 0 then x
else let r = f x in applyN_unfolded f r (n-1)

(*@
  predicate applyN(f, x, n, res) =
    Norm(n=0/\x=res/\emp, res) \/
    req n>0/\emp; ex r; f(x, r); ex r1; applyN(f, r, n-1, r1); Norm(res=r1/\emp, r1)
@*)

let[@proof unfold_right] rec applyN f x n
(*@ ex r3; applyN(f, x, n, r3) @*)
=
if n = 0 then x
else let r = f x in applyN f r (n-1)

let incr x
(*@ Norm(emp, x+1) @*)
= x + 1

(*@
  predicate incr(x, res) =
    Norm(res=x+1/\emp, res)
@*)

(*@
  lemma ih = applyN(incr, x, n, res) => Norm(res=x+n/\emp, res)
@*)

let[@proof unfold_left; apply ih] sum ()
(*@ Norm(emp, 10) @*)
= applyN incr 0 10

let incr2 x
(*@ Norm(emp, x+2) @*)
= x + 2

(*@
  predicate incr2(x, res) =
    Norm(res=x+2/\emp, res)
@*)

(*@
  lemma ih2 = applyN(incr, x, n, res) => Norm(res=x+n+n/\emp, res)
@*)

let[@proof unfold_left; apply ih2] sum2 ()
(*@ Norm(emp, 20) @*)
= applyN incr2 0 10

(*@
  lemma ih3 = applyN(incr, x, n, res) => Norm(res=x+n/\emp, res)
@*)

let[@proof unfold_left; apply ih3] summary x n
(*@ req n>0/\emp; ex r4; Norm(r4=x+n/\emp, r4) @*)
= applyN incr x n">src/examples/applyN.ml</option><option value=src/examples/compose.ml data-text="
let compose f g x
(*@
  ex r_g; g(x, r_g);
  ex r_f; f(r_g, r_f);
  Norm (emp, r_f)
@*)
= f (g x)

let f x 
(*@ ex z;
    req x->z;
    Norm(x->z+1, x) @*)
= x := !x + 1; x

let g x 
(*@ ex u;
    req x->u;
    ex ret;
    Norm(ret=u+u/\x->u+u, x) @*)
= x := !x + !x; x

let caller1 () 
(*@ ex w; Norm(w->3, 3) @*)
= let x = ref 1 in
  let y1 = compose f g x in
  !y1

let caller2 ()
(*@ ex w; Norm(w->4, 4) @*)
= let y = ref 1 in 
  let y1 = compose g f y in
  !y1">src/examples/compose.ml</option><option value=src/evaluation/0_heap_zero_once_twice.ml data-text="effect Zero : int 
effect Once : int 
effect Twice : int 

let test () 
(*@ ex i ret;
   Zero(i->0, ret);
   req i-> 0; 
   Norm(i->1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  let ret = perform Zero in 
  i := !i + 1;
  assert (!i = 1);
  ret

let main_aux ()
(*@ ex i;
   Norm(i->0, 100)
@*)
=
  match test () with
  | v -> v
  | effect Zero k -> 100
  | effect Once k ->
    (continue k 1); 
  | effect Twice k ->
    let _ = (continue (Obj.clone_continuation k) 1) in (continue k 2)">src/evaluation/0_heap_zero_once_twice.ml</option><option value=src/evaluation/10_memory_cell_nested.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let test ()
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, (x1+1), x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= 
  let x = read () in 
  let y = x +1 in 
  write y;
  read () 

let write_handler i  
(*@ 
  ex x1 ret z; 
  Read(emp, x1); 
  req i-> z; 
  Read(i->x1+1,  ret);
  Norm(emp, ret)
@*)
= 
  match test () with
  | v -> v
  | effect (Write x) k -> i := x; (continue k ())


let read_handler  ()
(*@ 
  ex i; 
  Norm(i->2,  10)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match write_handler i with
  | v -> v 
  | effect Read k -> (continue k (!i))">src/evaluation/10_memory_cell_nested.ml</option><option value=src/evaluation/11_exchange.ml data-text="effect Exchange: int -> int

let exchange (m:int)
(*@  
   ex ret;
   Exchange(emp, m, ret);
   Norm(emp, ret)
@*)
= perform (Exchange m)


let exc_hanlder (y: int ref) (new_v:int): int
(*@  
   ex old_v; 
   req y -> old_v; 
   Norm(y -> new_v, old_v)
@*)
= match exchange new_v with 
  | v -> v 
  | effect (Exchange n) k -> 
    let old_v = !y in 
    y := n; 
    continue k old_v


let main ()
(*@  
  ex x;
  Norm(x -> 5, 11)
@*)
= 
  let x = ref 11 in 
  let res = exc_hanlder x 5 in 
  print_endline (string_of_int res);
  res">src/evaluation/11_exchange.ml</option><option value=src/evaluation/12_two_pointers.ml data-text="effect E: unit 

let two_locations () 
(*@ ex i j z1 z2 ret;
   E(i->0 * j->0, ret);
   req i->z1 * j->z2; 
   Norm(i->z1+1*j->z2+1, ret)
@*)
= let i = ref 0 in 
  let j = ref 0 in 
  let ret = perform (E) in 
  i := !i + 1;
  j := !j + 1;
  ret">src/evaluation/12_two_pointers.ml</option><option value=src/evaluation/1_heap_zero_once_twice.ml data-text="effect Zero : int 
effect Once : int 
effect Twice : int 

let test () 
(*@ ex i ret;
   Once(i->0, ret);
   req i-> 0; 
   Norm(i->1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  let ret = perform Once in 
  i := !i + 1;
  assert (!i = 1);
  ret

let main_aux ()
(*@ ex i;
   Norm(i->1, 1)
@*)
=
  match test () with
  | v -> v
  | effect Zero k -> (-1)
  | effect Once k ->
    (continue k 1); 
  | effect Twice k ->
    let _ = (continue (Obj.clone_continuation k) 1) in (continue k 2)">src/evaluation/1_heap_zero_once_twice.ml</option><option value=src/evaluation/2_heap_zero_once_twice.ml data-text="effect Zero : int 
effect Once : int 
effect Twice : int 

let test () 
(*@ ex i ret;
   Twice(i->0, ret);
   req i-> 0; 
   Norm(i->1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  let ret = perform Twice in 
  i := !i + 1;
  assert (!i = 1);
  ret

let main_aux ()
(*@ ex i;
   Norm(i->2, 2)
@*)
=
  match test () with
  | v -> v
  | effect Zero k -> 100
  | effect Once k ->
    (continue k 1); 
  | effect Twice k ->
    let _ = (continue (Obj.clone_continuation k) 1) in (continue k 2)">src/evaluation/2_heap_zero_once_twice.ml</option><option value=src/evaluation/3_nestedHandlers.ml data-text="effect E : int 
effect F : string 

let foo () 
(*@ 
   ex ret; 
   F(emp, ret);
   Norm(emp, ret)
@*)
= perform F

let bar () 
(*@ 
   ex ret; 
   F(emp, ret);
   Norm(emp, ret)
@*)
=
  match foo () with 
  | x -> x 
  | effect E k -> (failwith &quot;impossible&quot;)

let baz () 
(*@ 
   Norm(emp, 1)
@*)
=
  match bar () with 
  | x -> x 
  | effect F k -> continue k 1">src/evaluation/3_nestedHandlers.ml</option><option value=src/evaluation/4_memory_cell.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)


let read_handler () 
(*@ 
  ex i; 
  Norm(i->0,  0)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match read () with 
  | v -> v
  | effect Read k -> (continue k (!i)) 



let write_handler  ()
(*@ 
  ex i; 
  Norm(i->10,  10)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match write 10 with
  | v -> !i (*print_string (string_of_int !i) *)
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/4_memory_cell.ml</option><option value=src/evaluation/5_memory_cell.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)


let read_handler ()
(*@ 
  ex i; 
  Norm(i->0,  0)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match read ();read () with 
  | v -> v
  | effect Read k -> (continue k (!i)) 



let write_handler  ()
(*@ 
  ex i; 
  Norm(i->20,  20)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match write 10; write 20 with
  | v -> !i (*print_string (string_of_int !i) *)
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/5_memory_cell.ml</option><option value=src/evaluation/6_memory_cell_mix_handler.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let test1 ()
(*@ 
  Write(emp, 10, x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= 
  write 10;
  read ()

let test ()
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, (x1+1), x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= 
  let x = read () in 
  let y = x +1 in 
  write y;
  read () 

let handler () 
(*@ 
  ex i; 
  Norm(i->1,  1)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match test () with 
  | v -> !i
  | effect Read k -> (continue k (!i)) 
  | effect (Write x) k -> i := x; (continue k ())



let handler1 () 
(*@ 
  ex i; 
  Norm(i->10,  10)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match test1 () with 
  | v -> !i
  | effect Read k -> (continue k (!i)) 
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/6_memory_cell_mix_handler.ml</option><option value=src/evaluation/7_memory_cell_mix_handler.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)


let test ()
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, (x1+1), x2); 
  ex x3; 
  Read(emp, x3); 
  ex x4; 
  Write(emp, (x3+1), x4); 
  ex x5; 
  Read(emp, x5); 
  Norm(emp, x5)
@*)
= 
  let x = read () in 
  write (x+1);
  let z = read () in 
  write (z+1);
  read ()

let handler () 
(*@ 
  ex i; 
  Norm(i->2,  2)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match test () with 
  | v -> !i
  | effect Read k -> (continue k (!i)) 
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/7_memory_cell_mix_handler.ml</option><option value=src/evaluation/8_memory_cell_nested.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let client () 
(*@ 
  ex x2;
  Write(emp, 10, x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= write 10;
  read () 
  

let handler1 i 
(*@ 
  ex z x3;
  req i -> z;
  Read(i ->10, x3); 
  Norm(emp, x3)
@*)
= 
  match client () with
  | v -> v
  | effect (Write x) k -> i := x; (continue k ())


let handler2  ()
(*@ 
   ex i; 
   Norm(i->10, ())
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match handler1 i with
  | v -> () (*print_string (string_of_int !i) *)
  | effect Read k -> (continue k (!i))">src/evaluation/8_memory_cell_nested.ml</option><option value=src/evaluation/9_memory_cell_nested.ml data-text="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let client () 
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, 10, x2); 
  Norm(emp, x2)
@*)
= read ();
  write 10

let handler1 i  
(*@ 
  ex ret ret1 z; 
  Read(emp, ret); 
  req i-> z; 
  Norm(i->10,  ())
@*)
= 
  match client () with
  | v -> ()
  | effect (Write x) k -> i := x; (continue k ())


let handler2  ()
(*@ 
  ex i; 
  Norm(i->10,  ())
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match handler1 i with
  | v -> v (*print_string (string_of_int !i) *)
  | effect Read k -> (continue k (!i))">src/evaluation/9_memory_cell_nested.ml</option>
        </select>
        <button id="share-btn" disabled onclick="share()">Share</button>
        <span style="display: inline-block">
          <!-- prevent the checkbox and label from wrapping separately -->
          <input type="checkbox" id="debug" style="vertical-align: middle" />
          <label for="debug" style="vertical-align: middle">Debug</label>
        </span>
      </div>
      <div id="output"></div>
    </div>
    <script type="text/javascript">
      const redirect_output = true;
      if (redirect_output) {
        const field = document.querySelector("#output");
        window.console = new Proxy(console, {
          get(_target, prop, _receiver) {
            let args = [...arguments];
            // old_console.warn(args);
            if (prop === "log") {
              return (...args) => {
                // field.value += args.join(' ') + '\n';
                field.innerHTML +=
                  '<div class="output-line">' +
                  args
                    .join(" ")
                    .replace(/\n/g, '</div><div class="output-line">') +
                  "</div>";
                // field.textContent += args.join(" ");
                // old_console.log(...args);
              };
            } else {
              return Reflect.get(...arguments);
            }
          },
        });
      }
    </script>
    <script src="coi-serviceworker.min.js"></script>
    <!-- z3-built has to be deferred -->
    <script type="text/javascript" src="z3-built.js"></script>
    <script type="text/javascript" src="ace_ocaml.js"></script>
    <script>
      // this is substituted at build time and is used in page.js
      function postExampleLoad() {
        console.log("Built Tue May 23 17:28:06 UTC 2023");
        console.log("loading z3...");
      }
    </script>
    <script type="text/javascript" src="page.js"></script>
    <!-- hipjs logs to the console (page) -->
    <script type="text/javascript" src="hipjs.bc.js"></script>
    <!-- bundle.js/main.js requires ocaml_ready (hipjs) and enable_buttons (page) to be defined -->
    <script type="text/javascript" src="bundle.js"></script>
  </body>
</html>
