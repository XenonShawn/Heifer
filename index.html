<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />

    <!-- stop google thinking this page is in spanish -->
    <meta name="google" content="notranslate" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ESL Demo</title>
    <script src="coi-serviceworker.min.js"></script>
    <script type="text/javascript" src="z3-built.js"></script>
    <script type="text/javascript" src="bundle.js"></script>
    <script type="text/javascript" defer src="hipjs.bc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ace-builds@1.20.0/src-min-noconflict/ace.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ace-builds@1.20.0/src-min-noconflict/ace.min.js"></script>
    <style>
      /* layout taken from https://github.com/mwillsey/egg-smol */
      body {
        margin: 0;
        display: flex;
        height: 100vh;
        width: 100vw;
      }

      #editor {
        width: 60%;
        resize: horizontal;
        overflow: auto;
        padding: 5px;
      }

      /* someday */
      /* #editor .CodeMirror { */
      #editor #input {
        width: 97%;
        height: 97%;

        /* disable all textarea styling */
        border: none;
        overflow: auto;
        outline: none;
        -webkit-box-shadow: none;
        -moz-box-shadow: none;
        box-shadow: none;
        resize: none;
      }

      #panel {
        padding: 10px;
        flex: 1 1 0;
        border-left: 2px solid gray;

        display: flex;
        flex-flow: column;

        /* this size causes no resizing of the output div when the output lines get long. */
        /* an alternative is break-all, see below */
        /* max-width: 37%; */
      }

      #toolbar button {
        margin-right: 5px;
      }

      #output {
        font-family: monospace;
        margin-top: 10px;
        flex-grow: 1;
        white-space: pre-wrap;
        overflow-y: scroll;
      }

      .output-error {
        /* color: red; */
        background-color: red;
        color: white;
        border-radius: 3px;
        padding: 0px 5px;
      }

      .output-ok {
        /* color: green; */
        background-color: green;
        color: white;
        border-radius: 3px;
        padding: 0px 5px;
      }

      .output-line {
        overflow-wrap: anywhere;
        /* overflow-wrap: break-word; */
        /* background: white; */
        min-height: 1em;
        line-height: 1;
      }

      /* .output-line:hover {
        background: lightblue;
      } */
    </style>
  </head>

  <body>
    <div id="editor"></div>
    <!-- <div id="editor">
      <textarea id="input" spellcheck="false"></textarea>
    </div> -->
    <div id="panel">
      <div id="toolbar">
        <button id="run-btn" disabled onclick="run()">Run</button>
        <select name="examples" id="examples" onchange="load_example(this)">
          <option
            value="effect Eff : unit

let test ()
(*@ ex i ;
  Eff(i->0, ret);
  req i-> z;
  Norm(i->z+1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in
  let ret = perform Eff in
  i := !i + 1;
  ret"
          >
            Hello world
          </option>
          <option value="effect Zero : int 
effect Once : int 
effect Twice : int 

let test () 
(*@ ex i ret;
   Zero(i->0, ret);
   req i-> 0; 
   Norm(i->1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  let ret = perform Zero in 
  i := !i + 1;
  assert (!i = 1);
  ret

let main_aux ()
(*@ ex i;
   Norm(i->0, 100)
@*)
=
  match test () with
  | v -> v
  | effect Zero k -> 100
  | effect Once k ->
    (continue k 1); 
  | effect Twice k ->
    let _ = (continue (Obj.clone_continuation k) 1) in (continue k 2)">src/evaluation/0_heap_zero_once_twice.ml</option><option value="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let test ()
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, (x1+1), x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= 
  let x = read () in 
  let y = x +1 in 
  write y;
  read () 

let write_handler i  
(*@ 
  ex x1 ret z; 
  Read(emp, x1); 
  req i-> z; 
  Read(i->x1+1,  ret);
  Norm(emp, ret)
@*)
= 
  match test () with
  | v -> v
  | effect (Write x) k -> i := x; (continue k ())


let read_handler  ()
(*@ 
  ex i; 
  Norm(i->2,  10)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match write_handler i with
  | v -> v 
  | effect Read k -> (continue k (!i))">src/evaluation/10_memory_cell_nested.ml</option><option value="effect Exchange: int -> int

let exchange (m:int)
(*@  
   ex ret;
   Exchange(emp, m, ret);
   Norm(emp, ret)
@*)
= perform (Exchange m)


let exc_hanlder (y: int ref) (new_v:int): int
(*@  
   ex old_v; 
   req y -> old_v; 
   Norm(y -> new_v, old_v)
@*)
= match exchange new_v with 
  | v -> v 
  | effect (Exchange n) k -> 
    let old_v = !y in 
    y := n; 
    continue k old_v


let main ()
(*@  
  ex x;
  Norm(x -> 5, 11)
@*)
= 
  let x = ref 11 in 
  let res = exc_hanlder x 5 in 
  print_endline (string_of_int res);
  res">src/evaluation/11_exchange.ml</option><option value="effect E: unit 

let two_locations () 
(*@ ex i j z1 z2 ret;
   E(i->0 * j->0, ret);
   req i->z1 * j->z2; 
   Norm(i->z1+1*j->z2+1, ret)
@*)
= let i = ref 0 in 
  let j = ref 0 in 
  let ret = perform (E) in 
  i := !i + 1;
  j := !j + 1;
  ret">src/evaluation/12_two_pointers.ml</option><option value="effect Zero : int 
effect Once : int 
effect Twice : int 

let test () 
(*@ ex i ret;
   Once(i->0, ret);
   req i-> 0; 
   Norm(i->1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  let ret = perform Once in 
  i := !i + 1;
  assert (!i = 1);
  ret

let main_aux ()
(*@ ex i;
   Norm(i->1, 1)
@*)
=
  match test () with
  | v -> v
  | effect Zero k -> (-1)
  | effect Once k ->
    (continue k 1); 
  | effect Twice k ->
    let _ = (continue (Obj.clone_continuation k) 1) in (continue k 2)">src/evaluation/1_heap_zero_once_twice.ml</option><option value="effect Zero : int 
effect Once : int 
effect Twice : int 

let test () 
(*@ ex i ret;
   Twice(i->0, ret);
   req i-> 0; 
   Norm(i->1, ret)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  let ret = perform Twice in 
  i := !i + 1;
  assert (!i = 1);
  ret

let main_aux ()
(*@ ex i;
   Norm(i->2, 2)
@*)
=
  match test () with
  | v -> v
  | effect Zero k -> 100
  | effect Once k ->
    (continue k 1); 
  | effect Twice k ->
    let _ = (continue (Obj.clone_continuation k) 1) in (continue k 2)">src/evaluation/2_heap_zero_once_twice.ml</option><option value="effect E : int 
effect F : string 

let foo () 
(*@ 
   ex ret; 
   F(emp, ret);
   Norm(emp, ret)
@*)
= perform F

let bar () 
(*@ 
   ex ret; 
   F(emp, ret);
   Norm(emp, ret)
@*)
=
  match foo () with 
  | x -> x 
  | effect E k -> (failwith &quot;impossible&quot;)

let baz () 
(*@ 
   Norm(emp, 1)
@*)
=
  match bar () with 
  | x -> x 
  | effect F k -> continue k 1">src/evaluation/3_nestedHandlers.ml</option><option value="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)


let read_handler () 
(*@ 
  ex i; 
  Norm(i->0,  0)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match read () with 
  | v -> v
  | effect Read k -> (continue k (!i)) 



let write_handler  ()
(*@ 
  ex i; 
  Norm(i->10,  10)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match write 10 with
  | v -> !i (*print_string (string_of_int !i) *)
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/4_memory_cell.ml</option><option value="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)


let read_handler ()
(*@ 
  ex i; 
  Norm(i->0,  0)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match read ();read () with 
  | v -> v
  | effect Read k -> (continue k (!i)) 



let write_handler  ()
(*@ 
  ex i; 
  Norm(i->20,  20)
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match write 10; write 20 with
  | v -> !i (*print_string (string_of_int !i) *)
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/5_memory_cell.ml</option><option value="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let test1 ()
(*@ 
  Write(emp, 10, x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= 
  write 10;
  read ()

let test ()
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, (x1+1), x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= 
  let x = read () in 
  let y = x +1 in 
  write y;
  read () 

let handler () 
(*@ 
  ex i; 
  Norm(i->1,  1)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match test () with 
  | v -> !i
  | effect Read k -> (continue k (!i)) 
  | effect (Write x) k -> i := x; (continue k ())



let handler1 () 
(*@ 
  ex i; 
  Norm(i->10,  10)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match test1 () with 
  | v -> !i
  | effect Read k -> (continue k (!i)) 
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/6_memory_cell_mix_handler.ml</option><option value="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)


let test ()
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, (x1+1), x2); 
  ex x3; 
  Read(emp, x3); 
  ex x4; 
  Write(emp, (x3+1), x4); 
  ex x5; 
  Read(emp, x5); 
  Norm(emp, x5)
@*)
= 
  let x = read () in 
  write (x+1);
  let z = read () in 
  write (z+1);
  read ()

let handler () 
(*@ 
  ex i; 
  Norm(i->2,  2)
@*)
= let i = Sys.opaque_identity (ref 0) in 
  match test () with 
  | v -> !i
  | effect Read k -> (continue k (!i)) 
  | effect (Write x) k -> i := x; (continue k ())">src/evaluation/7_memory_cell_mix_handler.ml</option><option value="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let client () 
(*@ 
  ex x2;
  Write(emp, 10, x2); 
  ex x3; 
  Read(emp, x3); 
  Norm(emp, x3)
@*)
= write 10;
  read () 
  

let handler1 i 
(*@ 
  ex z; 
  req i -> z;
  Read(i ->10, x3); 
  Norm(emp, x3)
@*)
= 
  match client () with
  | v -> v
  | effect (Write x) k -> i := x; (continue k ())


let handler2  ()
(*@ 
   ex i; 
   Norm(i->10, ())
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match handler1 i with
  | v -> () (*print_string (string_of_int !i) *)
  | effect Read k -> (continue k (!i))">src/evaluation/8_memory_cell_nested.ml</option><option value="effect Read : int 
effect Write : int -> unit 

(* let (i: int ref) = Sys.opaque_identity (ref 0) *)

let read () 
(*@ 
   ex ret; 
   Read(emp, ret);
   Norm(emp, ret)
@*)
= perform Read

let write n 
(*@ 
   ex ret; 
   Write(emp, n,  ret);
   Norm(emp, ret)
@*)
= perform (Write n)

let client () 
(*@ 
  ex x1; 
  Read(emp, x1); 
  ex x2; 
  Write(emp, 10, x2); 
  Norm(emp, x2)
@*)
= read ();
  write 10

let handler1 i  
(*@ 
  ex ret ret1 z; 
  Read(emp, ret); 
  req i-> z; 
  Norm(i->10,  ())
@*)
= 
  match client () with
  | v -> ()
  | effect (Write x) k -> i := x; (continue k ())


let handler2  ()
(*@ 
  ex i; 
  Norm(i->10,  ())
@*)
=
  let i = Sys.opaque_identity (ref 0) in 
  match handler1 i with
  | v -> v (*print_string (string_of_int !i) *)
  | effect Read k -> (continue k (!i))">src/evaluation/9_memory_cell_nested.ml</option>
        </select>
        <button id="share-btn" disabled onclick="share()">Share</button>
      </div>
      <div id="output"></div>
    </div>
    <script type="text/javascript" src="ace_ocaml.js"></script>
    <script type="text/javascript" src="page.js"></script>
  </body>
</html>
